# TDD에 대해서

TDD 흐름

---

TDD는 기능을 검증하는 테스트를 먼저 작성한다. 작성한 테스트를 통과하지 못하면 테스트를 통과할 만큼만 코드를 작성한다. 테스트를 통과한 뒤에는 개선할 코드가 있으면 리팩토링한다. 리팩토링을 수행한 뒤에는 다시 테스트를 실행해서 기존 기능이 망가지지 않았는지 확인한다. 이 과정을 반복하면서 점진적으로 기능을 완성해 나가는 것, 이것이 전형적인 TDD의 흐름이다.

레드-그린-리팩터

---

TDD 사이클을 레드(Red) - 그린(Green) - 리팩터(Refactor)라고 부른다. 

레드: 실패하는 테스트

그린: 성공한 테스트

레드에서 그린으로 간다: 코드를 구현해서 실패하는 테스트를 통과시키는 것을 뜻한다.

테스트가 개발을 주도

---

테스트 코드를 먼저 작성하면 테스트가 개발을 주도하게 된다.

테스트를 작성하는 과정에서 구현 생각 XXX

단지 해당 기능이 올바르게 동작하는지 검증할 수 있는 테스트 코드를 만들었을 뿐이다. (테스트를 통과시킬 만큼만 구현한다.)

테스트 코드를 만들면 다음 개발 범위가 정해진다.

테스트 코드가 추가되면서 범위가 넓어질수록 구현도 점점 완성되어간다. → 이게 바로 테스트 주도 개발.

- 리팩토링 하는데 과감해진다
- 코드 수정에 대한 피드백이 빠르다.
- 새로운 코드를 추가하거나 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 확인할 수 있다.

테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기

---

- 테스트 메서드가 특정 순서대로 실행된다는 가정하에 테스트 메서드를 작성하면 안된다.

@Disabled 애노테이션이 붙은 클래스나 메서드는 테스트 실행 대상에서 제외한다.

상황, 실행, 결과 확인은 영어 표현 given, when, then에 대응한다.

→ 너무 집착하지는 말자. 이 구조가 테스트 코드를 작성하는데 도움이 되는 것은 맞지만 꼭 모든 테스트 메서드를 이 구조로 만들어야 하는 것은 아니다. 테스트 코드를 보고 내용을 이해할 수 있으면 된다. 

상황 설정이 테스트 대상으로 국한되는 것은 아니다. 상황에는 외부 요인도 있다.

외부 상태가 테스트 결과에 영향을 주지 않게 하기.

- 테스트 실행 전에 외부를 원하는 상태로 만든다.
- 테스트 실행 후에 외부 상태를 원래대로 되돌려 놓아야 한다.

외부 상태와 테스트 어려움

---

테스트 대상이 아닌 외부 요인은 테스트 코드에서 다루기 힘든 존재이다. → “대역 사용”

대역이 필요한 상황

---

- 테스트 대상에서 파일 시스템을 이용
- 테스트 대상에서 DB로부터 데이터를 조회하거나 데이터를 추가
- 테스트 대상에서 외부 HTTP 서버와 통신

테스트 대상에서 의존하는 요인 때문에 테스트가 어려울 때는 대역을 써서 테스트를 진행할 수 있다. 

test double: 테스트에서 진짜 대신 사용할 대역을 의미한다.

대역의 종류는

스텁, 가짜, 스파이, 모의 객체가 존재한다.

각 대역 종류마다 쓰임새가 다르다.

대역의 종류

스텁(Stub): 구현을 단순한 것으로 대체한다. 테스트에 맞게 단순히 원하는 동작을 수행한다.

가짜(Fake): 제품에는 적합하지 않지만, 실제 동작하는 구현을 제공한다. DB대신에 메모리를 이용해서 구현한 

스파이(Spy): 호출된 내역을 기록한다. 기록한 내용은 테스트 결과를 검증할 때 사용한다. 스텁이기도 하다.

모의(Mock): 기대한 대로 상호작용 하는지 행위를 검증한다. 기대한 대로 동작하지 않으면 익셉션을 발생할 수 있다. 모의 객체는 스텁이자 스파이도 된다. 

단점이 존재할수도 있다.

모의 객체는 스텁과 스파이를 지원하므로 대역으로 모의 객체를 많이 사용한다. 하지만 모의 객체를 과하게 사용하면 오히려 테스트 코드가 복잡해지는 경우도 발생한다. 

모의 객체를 이용하면 대역 클래스를 만들지 않아도 되니까 처음에는 편할 수 있다. 하지만 결과 값을 확인하는 수단으로 모의 객체를 사용하기 시작하면 결과 검증 코드가 길어지고 복잡해진다. 특히 하나의 테스트를 위해 여러 모의 객체를 사용하기 시작하면 결과 검증 코드의 복잡도는 배로 증가한다. 게다가 모의 객체는 기본적으로 메서드 호출 여부를 검증하는 수단이기 때문에 테스트 대상과 모의 객체 간의 상호 작용이 조금만 바뀌어도 테스트가 깨지기 쉽다.

특히 DAO나 레포지토리와 같이 저장소에 대한 대역은 모의 객체를 사용하는 것보다 메모리를 이용한 가짜 구현을 사용하는 것이 테스트 코드 관리에 유리하다.  

테스트 가능한 설계

---

테스트가 어려운 코드는 무엇일까? 

- 하드 코딩된 경로, IP 주소, 포트 번호
- 의존 객체를 직접 생성
- 정적 메서드 사용 (예.. AuthUtil 클래스의 정적 메서드, )
- 실행 시점에 따라 달라지는 결과(LocalDate now = LocalDate.now() 와 같은,,, 날짜에 따라 달라지는 정책 ^^)
- 역할이 섞여 있는 코드
- 메서드 중간에 소켓 통신 코드가 포함되어 있다.
- 코솔에서 입력을 받거나 결과를 콘솔에 출력한다.
- 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어려울 수 있다.
- 테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다.

소켓 통신이나 HTTP 통신은 실제를 대체할 서버를 로컬에 띄워서 처리할 수 있다. 서버 수준에서 대역을 사용한다고 생각하면 된다. HTTP 서버를 대역으로 대신하는 예는 9장에서 소개한다.

그럼 테스트 가능한 설계는 무엇일까?

---

코드의 테스트가 어려운 주된 이유는 의존하는 코드를 교체할 수 있는 수단이 없기 때문이다. 상황에 따라 알맞은 방법을 적용하면 의존 코드를 교체할 수 있게 만들 수 있다.

- 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기
    - 상수 대신 메서드 파라미터로 값을 전달받도록 수정하면 다음과 같이 테스트 코드에서 파일 경로를 제어할 수 있게 된다.
- 의존 대상을 주입받기
    - 의존 대상은 주입 받을 수 있는 수단을 제공해서 교체할 수 있도록 한다. (생성자나 세터)
- 테스트하고 싶은 코드를 분리하기
- 시간이나 임의 값 생성 기능 분리하기
- 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기
    - 외부 라이브러리와 연동하기 위한 타입을 따로 만든다.
    - 테스트 대상은 분리한 타입을 사용하게 바꾼다.
    - 테스트 대상 코드는 새로 분리한 타입을 사용함으로써 외부 연동이 필요한 기능을 쉽게 대역으로 대체할 수 있게 된다.
    - 의존하는 대상이 final 클래스이거나 의존 대상의 호출 메서드가 final이어서 대역으로 재정의 할 수 없는 경우에도 동일한 기법을 적용해서 테스트 가능하게 만들 수 있다.

테스트 범위와 종류

---

하나의 기능이 올바르게 동작하려면 컨트롤러, 서비스, 모델과 같은 자바 코드와 프레임워크 설정에 문제가 없어야 할 뿐 아니라 브라우저에서 실행되는 자바스크립트 코드, HTML과 CSS등이 정상 동작해야 한다. 또한, DB의 테이블도 올바르게 생성되어 있어야 한다.

개발자가 코드를 조금씩 수정할 때마다 브라우저부터 DB까지의 전 범위를 테스트해야 하는 것은 아니며 출시 전에 DB와 연동할 때 사용한 쿼리만 확인해서도 안된다. 테스트의 범위는 테스트의 목적과 수행하는 사람에 따라 달라진다.

기능테스트와 E2E테스트

---

기능테스트(Functional Testing)는 사용자 입장에서 시스템이 제공하는 기능이 올바르게 동작하는지 확인한다.

- 이 테스트를 수행하려면 시스템을 구동하고 사용하는데 필요한 모든 구성 요소가 필요하다.
- 예) 회원가입 기능이 올바르게 동작하는지 확인하려면 웹 서버, 데이터베이스, 웹 브라우저가 필요하다.
- 회원 가입 과정에서 문자 발송 기능이 필요하다면 외부의 문자 발송 서비스도 필요하다.
- 기능 테스트는 사용자가 직접 사용하는 웹 브라우저나 모바일 앱부터 시작해서 데이터베이스나 외부 서비스에 이르기까지 모든 구성 요소를 하나로 엮어서 진행한다.
- 이는 끝(브라우저) 에서 끝(데이터베이스)까지 모든 구성 요소를 논리적으로 완전한 하나의 기능으로 다룬다.
- 기능 테스트는 끝에서 끝까지 올바른지 검사하기 때문에 E2E 테스트로도 볼 수 있다.
- QA 조직에서 수행하는 테스트가 주로 기능 테스트이다.
- 이때 테스트는 시스템이 필요로하는 데이터를 입력하고 결과가 올바른지 확인한다.
- 예) 회원가입 → 회원가입 폼을 통해서 가입했을 때 해당 정보로 로그인이 잘 되는지, 회원 정보를 조회할 때 가입할 때 입력한 데이터가 올바르게 표시되는지 등을 확인한다.

통합테스트

---

통합 테스트(Integration Testing)는 시스템의 각 구성 요소가 올바르게 연동되는지 확인한다. 기능 테스트가 사용자 입장에서 테스트하는 데 반해 통합 테스트는 소프트웨어의 코드를 직접 테스트한다.

모바일 앱을 예로 들면 기능 테스트는 앱을 통해 가입 기능을 테스트 한다면 통합테스트는 서버의 회원 가입 코드를 직접 테스트하는 식이다.

단위테스트

---

단위 테스트(Unit Testing)는 개별 코드나 컴포넌트가 기대한대로 동작하는지 확인한다. 단위 테스트는 한 클래스나 한 메서드와 같은 작은 범위를 테스트한다. 일부 의존 대상은 스텁이나 모의 객체를 이용해서 대역으로 대체한다.

테스트 범위 간 차이??

---

테스트 범위에 따른 테스트 코드 개수와 시간

- 기능 테스트를 수행하려면 브라우저나 모바일 앱과 같은 클라이언트부터 DB까지 모든 환경이 갖춰져야 하기에 자동화하거나 다양한 상황별로 테스트하기 어렵다. → 정기적으로 수행하는 기능 테스트는 정상적인 경우와 몇 가지 특수한 상황만 테스트 범위로 잡는다.
- 통합테스트는 기능 테스트에 비해 제약이 덜하다. 보통 기능테스트보다 통합 테스트를 더 많이 작성한다.
- 단위테스트는 통합 테스트로도 만들기 힘든 상황을 쉽게 구성할 수 있다.
- 단위 테스트에서 다양한 상황을 다루고, 통합 테스트나 기능 테스트는 주요 상황에 초점을 맞춰야 한다.

외부 API 스텁으로 대체

---

WireMock을 사용하면 스텁으로 대체 가능하다. 

- [https://ktko.tistory.com/entry/Spring-Boot-Test-방법](https://ktko.tistory.com/entry/Spring-Boot-Test-%EB%B0%A9%EB%B2%95)

 테스트 코드와 유지보수

---

테스트코드는 그 자체로 코드이기 때문에 제품 코드와 동일하게 유지보수 대상이 된다. 테스트 코드를 유지보수하는 데 시간이 많이 들기 시작하면 점점 테스트 코드를 손보지 않아 실패하는 테스트가 증가하게 된다. 이걸 방치하게 되면 어떤???

테스트 코드는 코드를 변경했을 때 기존 기능이 올바르게 동작하는지 확인하는 회귀 테스트 (regression test)를 자동화하는 수단으로도 사용된다.

결국 테스트 코드의 유지보수성도 좋아야 한다.

- [ ]  테스트 코드의 유지보수성 좋게 만드는 법??

미국의 범죄학자인 제임스 윌슨과 조지켈링이 1982년 3월에 공동 발표함.

깨진 유리창 이론: 사회 무질서에 관한 이론. 깨진 유리창 하나를 방치하면, 그 지점을 중심으로 범죄가 확산되기 시작한다는 이론. 사소한 무질서를 방치하면 큰 문제로 이어질 가능성이 높아진다는 의미를 담고 있다.

테스트 코드의 유지보수성 좋게 만드는 법?

---

- 변수나 필드를 사용해서 기댓값 표현하지 않기
    
    ```java
    @Test
    void dateFormat() {
    		LocalDate date = LocalDate.of(1945,8,15);
    		String dateStr = formatDate(date);
    		assertEquals(date.getYear() + "년 " + 
    							date.getMonthValue() + "월 " +
    							date.getDayOfMonth() + "일 ", dateStr);
    ```
    

이렇게 표현하면? 

- 문자열 연결이 있어 코드가 복잡하다.
- date.getMontValue()대신 date.getMonth()를 사용하면 테스트를 실행해서 테스트가 깨져야 비로소 실수를 알아챈다.

개선 방법

```java
@Test
void dateFormat() {
		LocalDate date = LocalDate.of(1945,8,15);
		String dateStr = formatDate(date);
		assertEquals("1945년 8월 15일", dateStr);
```

- 기대 값에 문자열 값을 사용했다.
- 복잡하지 않고 기대하는 값도 명확하게 표현했다.
- 변수를 사용할 때처럼 메서드를 잘못 사용할 일도 없다.
- 테스트가 깨지면 fromatDate() 메서드만 확인하면 된다.

- 두 개 이상을 검증하지 않기
    - 한 테스트에서 검증하는 내용이 두 개 이상이면 테스트 결과를 확인할 때 집중도가 떨어진다.

- 정확하게 일치하는 값으로 모의 객체 설정하지 않기
    - 모의 객체는 가능한 범용적인 값을 사용해서 기술해야 한다.
    - 한정된 값에 일치하도록 모의 객체를 사용하면 약간의 코드 수정만으로도 테스트는 실패하게 된다.
    - 테스트 코드의 일부 값을 수정하면 모의 객체 관련 코드도 함께 수정하는 번거로움이 있다.
    
- 과도하게 구현 검증하지 않기
    - 테스트 대상의 내부 구현을 검증하지 않는다.
    - 모의 객체를 사용할 때 이런일이 일어나기 쉽다.
    - 내부 구현을 검증하는 것이 나쁜 것은 아니지만 한 가지 단점이 있다.
    - 그것은 바로 구현을 조금만 변경해도 테스트가 깨질 가능성이 있다는 것이다.
    - 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다.
    - 이미 존재하는 코드에 단위 테스트를 추가하면 어쩔 수 없이 내부 구현을 검증해야 할 때도 있다.
    - 기능이 정상적으로 동작하는지 확인할 수단이 구현 검증밖에 없다면 모의 객체를 사용해서 테스트 코드를 작성해야 하지만 일단 테스트 코드를 작성한 뒤에는 점진적으로 코드를 리팩토링해서 구현이 아닌 결과를 검증할 수 있도록 시도해야 한다. 그렇게 함으로써 향후에 사소한 구현 변경으로 인해 테스트가 깨지는 것을 방지할 수 있고 또한 코드의 테스트 가능성도 높일 수 있다.
    
- 셋업을 이용해서 중복된 상황을 설정하지 않기
    - BeforeEach를 사용해라.
    - 몇 달 만에 테스트 코드를 다시 볼일이 생겼다고 생각하자.
    - or 다른 사람이 코드를 까본다고 생각하자.
    - 몇 달 만에 코드를 보면 기억이 잘 나지 않기 때문에 setUp() 메서드를 확인 해야 한다.
    - 코드를 위 아래로 이동하면서 실패한 원인을 분석해야 한다.
    - 또한 테스트가 깨지기 쉬운 구조가 된다.
    - 모든 테스트 메서드가 동일한 상황 코드를 공유하기 때문에 조금만 내용을 변경해도 테스트가 깨질 수 있다.
    - 코드가 다소 길어져도 테스트 메서드 자체는 스스로를 더 잘 설명할 수 있다.
    - 테스트에 실패해도 코드를 이리저리 왔다 갔다 하면서 보지 않아도 된다.
    - 각 테스트에 맞게 상황을 설정하는 것도 쉽다.
    - 실패한 테스트 메서드 위주로 코드를 보면 된다.
    - 한 테스트 메서드의 상황을 변경해도 다른 테스트에 영향을 주지 않는다.

- 통합 테스트에서 데이터 공유 주의하기.
    - sql 애노테이션으로 지정한 sql 파일은 테스트를 위한 상황을 만들어준다.

- 모든 테스트가 같은 값을 사용하는 데이터: 예) 코드값 데이터
    - 코드값 데이터는 (거의) 바뀌지 않으므로 모든 테스트가 동일한 코드값 데이터를 사용해도 문제 XX. 오히려 서로 다른 코드값 데이터를 사용하면 문제가 생길 수 있음.
    - 모든 테스트가 다른 값을 사용하면 안 되는 데이터는 동일한 데이터를 공유해도 된다.
- 테스트 메서드에서만 필요한 데이터: 예) 중복 ID 검사를 위한 회원 데이터
    - 특정 테스트 메서드에서만 의미 있는 데이터는 모든 테스트가 공유할 필요가 없다.

- 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기
- 예) UserGivenHelper {}

- 실행환경이 다르다고 실패하지 않기
- 실행 시점이 다르다고 실패하지 않기
- 랜덤하게 실패하지 않기
- 필요하지 않은 값은 설정하지 않기
- 단위 테스트를 위한 객체 보조 클래스
    - 단위 테스트 코드를 작성하다 보면 상황 구성을 위해 필요한 데이터가 다소 복잡할 때가 있다.
    - 테스트를 위한 객체 생성 클래스를 따로 만들면 이런 복잡함을 줄일 수 있다.
- 조건부로 검증하지 않기
- 통합테스트는 필요하지 않은 범위까지 연동하지 않기
- 더 이상 쓸모 없는 테스트

회귀 테스트

---

회귀 테스트는 개발하고 테스트한 소프트웨어가 이후에 코드를 수정해도 기존 코드가 올바르게 동작하는지 확인하기 위한 테스트이다.

junit이 있는데 assertJ를 사용하는 이유??

- 단언에 대한 표현력이 부족하다는 점이다.

isEqualTo()

isNotEqualTo()

isNull()

isNotNull()

isIn()

isNotIn()

isLessThan()

isLessThanOrEqualTo()

isGreaterThan()

isGreaterThanOrEqualTo()

isBetween()

isTrue()

isFalse()

String에 대한 검증

---

contains()

containsOnlyOnce()

containsOnlyDigits()

containsWhiteSpaces()

containsOnlyWhiteSpaces()

containsPattern()

containsPattern()

doesNotContain()

doesNotContainAnyWhiteSpaces()

doesNotContainOnlyWhiteSpaces()

doesNotContainPattern()

doesNotContainPattern()

startsWith()

doesNotStartsWith()

endsWith()

doesNotEndWith()

SoftAssertions로 모아서 검증하기

as()와

describedAs()로 설명달기

[https://incheol-jung.gitbook.io/docs/study/undefined-3/chap-10](https://incheol-jung.gitbook.io/docs/study/undefined-3/chap-10).

개발계의 특효약 TDD는 무엇? 알아보기 

```java
// 안좋은 사례
@Test
void dateFormat() {
		LocalDate date = LocalDate.of(1945,8,15);
		String dateStr = formatDate(date);
		assertEquals(date.getYear() + "년 " + 
							date.getMonthValue() + "월 " +
							date.getDayOfMonth() + "일 ", dateStr);

// 개선된 사례
@Test
void dateFormat() {
		LocalDate date = LocalDate.of(1945,8,15);
		String dateStr = formatDate(date);
		assertEquals("1945년 8월 15일", dateStr);

// 안좋은 사례
@Test
void checkArray() {
		assertAll(
				() -> assertEquals(answers.get(0), resultedAnswers.get(0)),
				() -> assertEquals(answers.get(1), resultedAnswers.get(1)),
				() -> assertEquals(answers.get(2), resultedAnswers.get(2))
		)
}

// 개선된 사례
@Test
void checkArray() {
		assertAll(
				() -> assertEquals(1, resultedAnswers.get(0)),
				() -> assertEquals(2, resultedAnswers.get(1)),
				() -> assertEquals(3, resultedAnswers.get(2))
		)
}
```